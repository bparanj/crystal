## Symbolic Calls

```elixir
  def dict_gen() do
    let(x <- list({integer(), integer()}), do: :dict.from_list(x))
  end

  def dict_symb(),
    do: sized(size, dict_symb(size, {:call, :dict, :new, []}))

  def dict_symb(0, dict), do: dict

  def dict_symb(n, dict) do
    dict_symb(n - 1, {:call, :dict, :store, [integer(), integer(), dict]})
  end

  def dict_autosymb() do
    sized(size, dict_autosymb(size, {:"$call", :dict, :new, []}))
  end

  def dict_autosymb(0, dict), do: dict

  def dict_autosymb(n, dict) do
    dict_autosymb(
      n - 1,
      {:"$call", :dict, :store, [integer(), integer(), dict]}
    )
  end
```

These functions generate dictionaries using the PropCheck library.  The `dict_gen` function generates a dictionary from a list of integer pairs. It uses the `let` macro from PropCheck to define a generator that depends on the value of another generator. In this case, it generates a list of integer pairs using the `list({integer(), integer()})` generator, then converts the list to a dictionary using the `:dict.from_list(x)` function.

The `dict_symb` and `dict_autosymb` functions generate dictionaries in a different way. They use the `sized` function from PropCheck to generate a dictionary of a certain size. The size is passed to a helper function along with an initial empty dictionary.

The helper function has two versions to handle different cases:

1. When the size is 0, it returns the current dictionary.
2. Otherwise, it calls itself with the size decreased by 1 and a new dictionary that includes a new key-value pair. The key and value are both integers.

The difference between `dict_symb` and `dict_autosymb` is the way they represent the dictionary. `dict_symb` uses the `:call` atom, while `dict_autosymb` uses the `:"$call"` atom. This could be related to the way the dictionaries are used or printed in the tests.

These functions show how to use property-based testing to generate complex, realistic test data. They generate a large number of dictionaries with different sizes and key-value pairs, and check that a function behaves as expected with all these inputs.

```elixir
  property "dict generator" do
    forall d <- dict_gen() do
      :dict.size(d) < 5
    end
  end

  property "symbolic generator" do
    forall d <- dict_symb() do
      # propcheck does not automatically handle eval() calls
      :proper_gen.eval(:dict.size(d)) < 5
    end
  end

  property "automated symbolic generator" do
    forall d <- dict_autosymb() do
      :dict.size(d) < 5
    end
  end
```

These tests are designed to verify certain properties of dictionaries generated by three different functions: `dict_gen`, `dict_symb`, and `dict_autosymb`.

```elixir
  property "dict generator" do
    forall d <- dict_gen() do
      :dict.size(d) < 5
    end
  end
	
```

The first test, "dict generator", generates a dictionary using the `dict_gen` function and checks that its size is less than 5. The `forall` macro from PropCheck is used to express that the property should hold for all dictionaries generated by `dict_gen`.

```elixir
  property "symbolic generator" do
    forall d <- dict_symb() do
      # propcheck does not automatically handle eval() calls
      :proper_gen.eval(:dict.size(d)) < 5
    end
  end
```

The second test, "symbolic generator", generates a symbolic dictionary using the `dict_symb` function and checks that its size is less than 5. However, because `dict_symb` generates symbolic dictionaries, the `:proper_gen.eval` function is used to evaluate the size of the dictionary. This is necessary because PropCheck does not automatically handle evaluation of symbolic values.

```elixir
  property "automated symbolic generator" do
    forall d <- dict_autosymb() do
      :dict.size(d) < 5
    end
  end
```

The third test, "automated symbolic generator", generates a symbolic dictionary using the `dict_autosymb` function and checks that its size is less than 5. This test is similar to the second one, but it uses a different function to generate the symbolic dictionary.

These tests are a good example of how to use property-based testing to verify properties of complex data structures. They generate a large number of dictionaries with different sizes and key-value pairs, and check that the size of each dictionary is less than 5.
